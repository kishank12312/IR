<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pageRank API documentation</title>
<meta name="description" content="Web Graph Page Ranking This aims at implementing the PageRank Algorithm from stratch. The algorithm is implemented with and without teleportations â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pageRank</code></h1>
</header>
<section id="section-intro">
<p>Web Graph Page Ranking This aims at implementing the PageRank Algorithm from stratch. The algorithm is implemented with and without teleportations using numerical linear algebra package and Power Iteration Method We are taking the teleportation value as 0.1.</p>
<p>The program allows user to enter the query in form of a graph. The user is expected to enter the number of nodes and if the user wants a edge between 1 and 2 then he should enter "1 2" when prompted for the edges.</p>
<p>Functions and their uses:</p>
<p>The webpage ranks are calculated through the following methods:
1. Numerical Linear Algebra Package:
This method uses the linear algebra package in python to calculate the left eigen values and vectors
2. Power Iteration Method:
This method uses power iteration with a precision of 1e-8, and a max iteration limit of 500 to calculate the values.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#39;&#39;&#39;
Web Graph Page Ranking This aims at implementing the PageRank Algorithm from stratch. The algorithm is implemented with and without teleportations using numerical linear algebra package and Power Iteration Method We are taking the teleportation value as 0.1.

The program allows user to enter the query in form of a graph. The user is expected to enter the number of nodes and if the user wants a edge between 1 and 2 then he should enter &#34;1 2&#34; when prompted for the edges.

Functions and their uses:
 
The webpage ranks are calculated through the following methods:
1. Numerical Linear Algebra Package: 
    This method uses the linear algebra package in python to calculate the left eigen values and vectors
2. Power Iteration Method: 
    This method uses power iteration with a precision of 1e-8, and a max iteration limit of 500 to calculate the values.
&#39;&#39;&#39;

import numpy as np

# number of nodes in the graph 
n=0

# number of edges
e=0
 
n = int(input(&#34;Enter number of vertices/nodes in graph: &#34;))
e = int(input(&#34;Enter number of edges in graph: &#34;))

# adjecency matrix for the input graph
adjacencyMatrix = [[0 for i in range(n)] for j in range(n)]
 
for i in range(e):
    v1, v2 = map(int, input(&#34;Enter pair of vertices: &#34;).split())
    adjacencyMatrix[v1-1][v2-1] = 1
 
 
def vectorDifferenceError(matrix1, matrix2):
    &#39;&#39;&#39;Calculates the vector difference error of two matrices given as input&#39;&#39;&#39;    
    difference = 0
    for i in range(n):
        difference += abs(matrix1[i] - matrix2[i])
    return difference
 
def PageRank(alpha):
    &#39;&#39;&#39;
    Main funciton which calculates the pageRank of the input graph given by the user.
    Input is alpha which is the teleportation value.
    In this program we have taken a default value of 0.1/
    It calculates the rank by two methods - linear algebra method and power method
    Outputs the corresponding ranks calculated in descending order.
    &#39;&#39;&#39;
    
    vectorProduct = np.zeros(n)
    vectorProduct[3] = 1
    transitionProbabilityMatrix = []
 
    for i in adjacencyMatrix:
        if 1 not in i:
            transitionProbabilityMatrix.append([x/n for x in range(n)])
        else:
            transitionProbabilityMatrix.append(list(i))
 
    for i in range(n):
        onesCount = transitionProbabilityMatrix[i].count(1)
        for j in range(n):
            if transitionProbabilityMatrix[i][j] == 1:
                transitionProbabilityMatrix[i][j] = 1/onesCount
 
    for i in range(n):
        for j in range(n):
            transitionProbabilityMatrix[i][j] *= (1-alpha)
            transitionProbabilityMatrix[i][j] += (alpha/n)
 
    matrixP = np.array(transitionProbabilityMatrix)

    # iteration limit
    iterationlimit = 500
    while iterationlimit:
        initDistribution = vectorProduct
        vectorProduct = vectorProduct @ matrixP
        if vectorDifferenceError(vectorProduct, initDistribution) &lt; 10**(-8):
            break
        iterationlimit -=1
 
    w,v = np.linalg.eig(matrixP.T)
    x = v[:,0].real
 
    PageRankArrPower = vectorProduct
    PageRankArrLinAlg = x/sum(x)
 
    PageRankPower = []
    PageRankLinAlg =[]
    for i in range(n):
        PageRankPower.append((i, PageRankArrPower[i]))
        PageRankLinAlg.append((i, PageRankArrLinAlg[i]))
 
    # sorting the values in the descending order
    PageRankPower.sort(reverse=True, key=lambda x:x[1])
    PageRankLinAlg.sort(reverse=True, key=lambda x:x[1])
 
    return PageRankPower, PageRankLinAlg
 
PageRankPower, PageRankLinAlg  = PageRank(0.1)
 
# printing values of page rank calculated
print(&#34;The ranking of the Pages in descending order, with Random Teleportaion is: &#34;)
print(&#34;\t By Power Iteration: &#34;)
for i in range(n):
    print(&#39;\t\t&#39;, PageRankPower[i][0]+1, &#34;(Weight: &#34;, PageRankPower[i][1], &#34;)&#34;)
 
print(&#34;\t By Linear Algebra: &#34;)
for i in range(n):
    print(&#39;\t\t&#39;, PageRankLinAlg[i][0]+1, &#34;(Weight: &#34;, PageRankLinAlg[i][1], &#34;)&#34;)
 
 

 
adjacencyMatrix = np.array(adjacencyMatrix)
TPMatrix = adjacencyMatrix/adjacencyMatrix.sum(axis=1)

def PagerankNoTeleport():
    &#39;&#39;&#39;
    Function to calculate the pageRank without teleporation
    Ouputs the pageRank with linear algebra method and power method.
    &#39;&#39;&#39;
    rank = 100*np.ones(n)/n
    count = 0
    prevRank = rank
    
    rank = np.dot(TPMatrix, rank)
    while(np.linalg.norm(prevRank-rank) &gt; 0.01 and count&lt;250):
        prevRank = rank
        rank = np.dot(TPMatrix, rank)
        count +=1
 
    w, v = np.linalg.eig(TPMatrix)
    EVOrdering = np.absolute(w).argsort()[::-1]
    eigenVal = w[EVOrdering]
    eigenVec = v[:, EVOrdering]
    linAlgRank = eigenVec[:,0]
 
    PageRankPowerNoTP = []
    PageRankLinAlgNoTP =[]
 
    PageRankArrPower = rank/sum(rank)
    PageRankArrLinAlg = np.abs(np.real(linAlgRank))/2
 
    for i in range(n):
        PageRankPowerNoTP.append((i, PageRankArrPower[i]))
        PageRankLinAlgNoTP.append((i, PageRankArrLinAlg[i]))
 
    PageRankPowerNoTP.sort(reverse=True, key=lambda x:x[1])
    PageRankLinAlgNoTP.sort(reverse=True, key=lambda x:x[1])
 
    return PageRankPowerNoTP, PageRankLinAlgNoTP
 

# calculates the PageRank without teleportation and prints the corresponding values 
PageRankPowerNoTP, PageRankLinAlgNoTP = PagerankNoTeleport()
 
print(&#34;The ranking of the Pages in descending order, without Random Teleportaion is: &#34;)
print(&#34;\t By Power Iteration: &#34;)
for i in range(n):
    print(&#39;\t\t&#39;, PageRankPowerNoTP[i][0]+1, &#34;(Weight: &#34;, PageRankPowerNoTP[i][1],&#34;)&#34;)
 
print(&#34;\t By Linear Algebra: &#34;)
for i in range(n):
    print(&#39;\t\t&#39;, PageRankLinAlgNoTP[i][0]+1, &#34;(Weight: &#34;, PageRankLinAlgNoTP[i][1],&#34;)&#34;)
 
 </code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pageRank.PageRank"><code class="name flex">
<span>def <span class="ident">PageRank</span></span>(<span>alpha)</span>
</code></dt>
<dd>
<div class="desc"><p>Main funciton which calculates the pageRank of the input graph given by the user.
Input is alpha which is the teleportation value.
In this program we have taken a default value of 0.1/
It calculates the rank by two methods - linear algebra method and power method
Outputs the corresponding ranks calculated in descending order.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def PageRank(alpha):
    &#39;&#39;&#39;
    Main funciton which calculates the pageRank of the input graph given by the user.
    Input is alpha which is the teleportation value.
    In this program we have taken a default value of 0.1/
    It calculates the rank by two methods - linear algebra method and power method
    Outputs the corresponding ranks calculated in descending order.
    &#39;&#39;&#39;
    
    vectorProduct = np.zeros(n)
    vectorProduct[3] = 1
    transitionProbabilityMatrix = []
 
    for i in adjacencyMatrix:
        if 1 not in i:
            transitionProbabilityMatrix.append([x/n for x in range(n)])
        else:
            transitionProbabilityMatrix.append(list(i))
 
    for i in range(n):
        onesCount = transitionProbabilityMatrix[i].count(1)
        for j in range(n):
            if transitionProbabilityMatrix[i][j] == 1:
                transitionProbabilityMatrix[i][j] = 1/onesCount
 
    for i in range(n):
        for j in range(n):
            transitionProbabilityMatrix[i][j] *= (1-alpha)
            transitionProbabilityMatrix[i][j] += (alpha/n)
 
    matrixP = np.array(transitionProbabilityMatrix)

    # iteration limit
    iterationlimit = 500
    while iterationlimit:
        initDistribution = vectorProduct
        vectorProduct = vectorProduct @ matrixP
        if vectorDifferenceError(vectorProduct, initDistribution) &lt; 10**(-8):
            break
        iterationlimit -=1
 
    w,v = np.linalg.eig(matrixP.T)
    x = v[:,0].real
 
    PageRankArrPower = vectorProduct
    PageRankArrLinAlg = x/sum(x)
 
    PageRankPower = []
    PageRankLinAlg =[]
    for i in range(n):
        PageRankPower.append((i, PageRankArrPower[i]))
        PageRankLinAlg.append((i, PageRankArrLinAlg[i]))
 
    # sorting the values in the descending order
    PageRankPower.sort(reverse=True, key=lambda x:x[1])
    PageRankLinAlg.sort(reverse=True, key=lambda x:x[1])
 
    return PageRankPower, PageRankLinAlg</code></pre>
</details>
</dd>
<dt id="pageRank.PagerankNoTeleport"><code class="name flex">
<span>def <span class="ident">PagerankNoTeleport</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to calculate the pageRank without teleporation
Ouputs the pageRank with linear algebra method and power method.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def PagerankNoTeleport():
    &#39;&#39;&#39;
    Function to calculate the pageRank without teleporation
    Ouputs the pageRank with linear algebra method and power method.
    &#39;&#39;&#39;
    rank = 100*np.ones(n)/n
    count = 0
    prevRank = rank
    
    rank = np.dot(TPMatrix, rank)
    while(np.linalg.norm(prevRank-rank) &gt; 0.01 and count&lt;250):
        prevRank = rank
        rank = np.dot(TPMatrix, rank)
        count +=1
 
    w, v = np.linalg.eig(TPMatrix)
    EVOrdering = np.absolute(w).argsort()[::-1]
    eigenVal = w[EVOrdering]
    eigenVec = v[:, EVOrdering]
    linAlgRank = eigenVec[:,0]
 
    PageRankPowerNoTP = []
    PageRankLinAlgNoTP =[]
 
    PageRankArrPower = rank/sum(rank)
    PageRankArrLinAlg = np.abs(np.real(linAlgRank))/2
 
    for i in range(n):
        PageRankPowerNoTP.append((i, PageRankArrPower[i]))
        PageRankLinAlgNoTP.append((i, PageRankArrLinAlg[i]))
 
    PageRankPowerNoTP.sort(reverse=True, key=lambda x:x[1])
    PageRankLinAlgNoTP.sort(reverse=True, key=lambda x:x[1])
 
    return PageRankPowerNoTP, PageRankLinAlgNoTP</code></pre>
</details>
</dd>
<dt id="pageRank.vectorDifferenceError"><code class="name flex">
<span>def <span class="ident">vectorDifferenceError</span></span>(<span>matrix1, matrix2)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates the vector difference error of two matrices given as input</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vectorDifferenceError(matrix1, matrix2):
    &#39;&#39;&#39;Calculates the vector difference error of two matrices given as input&#39;&#39;&#39;    
    difference = 0
    for i in range(n):
        difference += abs(matrix1[i] - matrix2[i])
    return difference</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pageRank.PageRank" href="#pageRank.PageRank">PageRank</a></code></li>
<li><code><a title="pageRank.PagerankNoTeleport" href="#pageRank.PagerankNoTeleport">PagerankNoTeleport</a></code></li>
<li><code><a title="pageRank.vectorDifferenceError" href="#pageRank.vectorDifferenceError">vectorDifferenceError</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>